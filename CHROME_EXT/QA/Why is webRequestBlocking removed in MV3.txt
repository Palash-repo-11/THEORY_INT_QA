webRequestBlocking was removed in Manifest V3 because it fundamentally conflicted with Chrome‚Äôs security, privacy, and performance goals at scale.
This wasn‚Äôt an arbitrary API removal‚Äîit was an architectural decision.

Here‚Äôs the clear, non-hand-wavy explanation.

1. What webRequestBlocking Actually Did

In MV2, for every network request:

Network Request
   ‚Üì
Extension JS runs
   ‚Üì (blocking)
Extension decides allow / block / modify
   ‚Üì
Request continues

Problems:

JavaScript ran on the critical path

Browser had to wait for extensions

One slow extension = slow page

One malicious extension = data exfiltration

2. Performance at Chrome Scale

Chrome runs on:

Billions of devices

Low-end hardware

Mobile CPUs

Constrained memory

With webRequestBlocking:

Hundreds of requests per page

JS executed for each

Context switches

Garbage creation

üëâ This does not scale.

Even ‚Äúgood‚Äù extensions caused:

Page load delays

Battery drain

Jank

3. Security & Privacy Risks
With blocking webRequest, extensions could:

Read full URLs (including tokens)

Read headers (cookies, auth)

Read POST bodies

Modify responses

This enabled:

Credential harvesting

Session hijacking

Undetectable tracking

Malicious surveillance

All without user visibility.

4. Impossible to Enforce Safety

Because logic ran in JS:

Chrome couldn‚Äôt reason about behavior

Couldn‚Äôt optimize execution

Couldn‚Äôt guarantee determinism

Couldn‚Äôt audit intent

Every request was:

‚ÄúTrust arbitrary JS written by someone else‚Äù

That‚Äôs a non-starter at browser scale.

5. DeclarativeNetRequest (DNR) Solves This

MV3 replaced imperative code with declarative rules.

Network Request
   ‚Üì
Chrome Native Engine
   ‚Üì
Rules evaluated (no JS)
   ‚Üì
Allow / Block / Redirect

Benefits:

Zero JS per request

Deterministic behavior

Auditable rules

Native performance

Reduced data exposure

Extensions:

Can no longer read request bodies

Cannot dynamically exfiltrate data

Cannot slow down page loads

6. Why Not Keep Both APIs?

Because one bad extension ruins the model.

Chrome cannot:

Partially trust extensions

Predict extension behavior

Kill blocking JS safely mid-request

So Chrome chose:

Predictable, safe, and fast over unlimited power

7. Tradeoffs (Yes, There Are Real Ones)
Lost capabilities:

‚ùå Dynamic per-request decisions
‚ùå POST body inspection
‚ùå Arbitrary JS logic
‚ùå Full response modification

Gained capabilities:

‚úÖ Massive performance gains
‚úÖ Strong privacy guarantees
‚úÖ Better battery life
‚úÖ Extension ecosystem safety

8. Why Ad Blockers Still Work

Ad blockers:

Mostly rely on URL patterns

Do not need request bodies

Fit declarative rules well

That‚Äôs why uBlock Origin Lite works under MV3.

Heavy dynamic logic ‚Üí move server-side.

9. Chrome‚Äôs Unstated Goal (Reality)

Chrome needed:

To safely support millions of extensions

On billions of devices

Without trusting extension authors

webRequestBlocking violated that premise.

10. TL;DR
MV2	MV3
JS blocks requests	Native rules
Slow & unpredictable	Fast & deterministic
Full request access	Minimal data exposure
Hard to audit	Auditable
Easy to abuse	Much harder to abuse

webRequestBlocking wasn‚Äôt removed because it was powerful.
It was removed because it was too powerful to be safe.