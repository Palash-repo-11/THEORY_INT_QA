# üîµ REACT QUERY (TanStack Query) ‚Äì INTERVIEW QUESTIONS WITH ANSWERS & CODE

---

## 1Ô∏è‚É£ What is React Query?

React Query (TanStack Query) is a **server-state management library** for React.

‚û°Ô∏è It handles **fetching, caching, syncing, and updating server data** automatically.

---

## 2Ô∏è‚É£ Server State vs Client State

| Server State          | Client State            |
| --------------------- | ----------------------- |
| Data from API         | UI state (modal, theme) |
| Async                 | Sync                    |
| Can change externally | Controlled by app       |

üëâ React Query manages **server state**.

---

## 3Ô∏è‚É£ Why do we need React Query?

* No manual loading/error state
* Automatic caching
* Background refetching
* Request deduplication
* Better than Redux for API state

---

## 4Ô∏è‚É£ React Query vs Redux

| React Query      | Redux               |
| ---------------- | ------------------- |
| Server state     | Client/global state |
| Less boilerplate | More boilerplate    |
| Auto caching     | Manual handling     |

---

## 5Ô∏è‚É£ Core Concepts of React Query

* Query
* Query Key
* Query Cache
* Mutation
* Invalidation

---

## 6Ô∏è‚É£ Installation

```bash
npm install @tanstack/react-query
```

---

## 7Ô∏è‚É£ Setup QueryClient

```jsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <MyApp />
    </QueryClientProvider>
  );
}
```

---

## 8Ô∏è‚É£ What is useQuery?

`useQuery` is used to **fetch and cache data**.

```js
useQuery({ queryKey, queryFn })
```

---

## 9Ô∏è‚É£ Basic useQuery Example

```js
import { useQuery } from "@tanstack/react-query";

function Users() {
  const { data, isLoading, error } = useQuery({
    queryKey: ["users"],
    queryFn: () =>
      fetch("https://jsonplaceholder.typicode.com/users").then(res => res.json())
  });

  if (isLoading) return <p>Loading...</p>;
  if (error) return <p>Error</p>;

  return data.map(u => <p key={u.id}>{u.name}</p>);
}
```

---

## üîü What is queryKey?

A **unique identifier** for cached data.

```js
["users", userId]
```

---

## 1Ô∏è‚É£1Ô∏è‚É£ Why queryKey is important?

* Caching
* Refetching
* Invalidation

---

## 1Ô∏è‚É£2Ô∏è‚É£ Dynamic Queries Example

```js
useQuery({
  queryKey: ["user", id],
  queryFn: () => fetch(`/api/user/${id}`).then(res => res.json())
});
```

---

## 1Ô∏è‚É£3Ô∏è‚É£ What is enabled option?

Used to **conditionally run query**.

```js
useQuery({
  queryKey: ["user", id],
  queryFn,
  enabled: !!id
});
```

---

## 1Ô∏è‚É£4Ô∏è‚É£ What is staleTime?

Time data is considered **fresh**.

```js
staleTime: 1000 * 60 // 1 minute
```

---

## 1Ô∏è‚É£5Ô∏è‚É£ What is cacheTime?

How long unused cache stays.

```js
cacheTime: 1000 * 60 * 5
```

---

## 1Ô∏è‚É£6Ô∏è‚É£ Background Refetching

Refetches when:

* Window focus
* Network reconnect

---

## 1Ô∏è‚É£7Ô∏è‚É£ What is useMutation?

Used for **POST, PUT, DELETE** (write operations).

```js
useMutation({ mutationFn })
```

---

## 1Ô∏è‚É£8Ô∏è‚É£ Basic useMutation Example

```js
import { useMutation, useQueryClient } from "@tanstack/react-query";

function AddUser() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: (user) =>
      fetch("/api/users", {
        method: "POST",
        body: JSON.stringify(user)
      }),
    onSuccess: () => {
      queryClient.invalidateQueries(["users"]);
    }
  });

  return (
    <button onClick={() => mutation.mutate({ name: "Palash" })}>
      Add User
    </button>
  );
}
```

---

## 1Ô∏è‚É£9Ô∏è‚É£ Why invalidateQueries?

To **refetch fresh data** after mutation.

---

## 2Ô∏è‚É£0Ô∏è‚É£ Mutation Lifecycle

* onMutate
* onSuccess
* onError
* onSettled

---

## 2Ô∏è‚É£1Ô∏è‚É£ Optimistic Update Example

```js
useMutation({
  mutationFn: addTodo,
  onMutate: async (newTodo) => {
    await queryClient.cancelQueries(["todos"]);

    const previousTodos = queryClient.getQueryData(["todos"]);

    queryClient.setQueryData(["todos"], old => [...old, newTodo]);

    return { previousTodos };
  },
  onError: (err, newTodo, context) => {
    queryClient.setQueryData(["todos"], context.previousTodos);
  },
  onSettled: () => {
    queryClient.invalidateQueries(["todos"]);
  }
});
```

---

## 2Ô∏è‚É£2Ô∏è‚É£ useQuery vs useMutation

| useQuery | useMutation     |
| -------- | --------------- |
| GET      | POST/PUT/DELETE |
| Auto run | Manual trigger  |
| Cached   | Not cached      |

---

## 2Ô∏è‚É£3Ô∏è‚É£ Error Handling in React Query

```js
useQuery({
  queryKey,
  queryFn,
  retry: 2
});
```

---

## 2Ô∏è‚É£4Ô∏è‚É£ Pagination Example

```js
useQuery({
  queryKey: ["users", page],
  queryFn: () => fetch(`/api/users?page=${page}`).then(r => r.json()),
  keepPreviousData: true
});
```

---

## 2Ô∏è‚É£5Ô∏è‚É£ Parallel Queries

```js
useQueries({
  queries: [
    { queryKey: ["users"], queryFn: fetchUsers },
    { queryKey: ["posts"], queryFn: fetchPosts }
  ]
});
```

---

## 2Ô∏è‚É£6Ô∏è‚É£ React Query DevTools

```bash
npm install @tanstack/react-query-devtools
```

---

## 2Ô∏è‚É£7Ô∏è‚É£ When NOT to use React Query?

* UI state
* Form state
* Local state

---

## 2Ô∏è‚É£8Ô∏è‚É£ Common Mistakes

‚ùå Using Redux for API calls
‚ùå Not using queryKey properly
‚ùå Forgetting invalidation

---

## 2Ô∏è‚É£9Ô∏è‚É£ Interview One-Liner

"React Query efficiently manages server state by handling caching, background updates, and mutations with minimal code."

---

## 3Ô∏è‚É£0Ô∏è‚É£ MUST PRACTICE BEFORE INTERVIEW

‚úÖ useQuery
‚úÖ useMutation
‚úÖ queryKey
‚úÖ invalidateQueries
‚úÖ optimistic updates

---

## üéØ YOU ARE NOW STRONG IN:

üî• Server-state management
üî• API performance
üî• Modern React data fetching

---

If you want next (recommended):

* ‚ö° **RTK Query vs React Query**
* ‚ö° **React Query advanced patterns**
* ‚ö° **Caching & invalidation scenarios**
* ‚ö° **Senior frontend interview questions**

Just tell me üëç
