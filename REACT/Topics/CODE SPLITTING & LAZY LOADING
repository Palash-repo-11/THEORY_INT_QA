# üîµ CODE SPLITTING & LAZY LOADING ‚Äì REACT INTERVIEW QUESTIONS WITH ANSWERS & CODE

---

## 1Ô∏è‚É£ What is Code Splitting?

Code splitting is a technique to **split a large JavaScript bundle into smaller chunks** that are loaded **on demand**.

‚û°Ô∏è Improves **initial load time**.

---

## 2Ô∏è‚É£ Why is Code Splitting important?

* Faster initial page load
* Better performance
* Reduced bundle size
* Improved user experience

---

## 3Ô∏è‚É£ What is Lazy Loading?

Lazy loading means **loading components only when they are needed**.

‚û°Ô∏è A form of code splitting.

---

## 4Ô∏è‚É£ Difference between Code Splitting & Lazy Loading?

| Code Splitting | Lazy Loading      |
| -------------- | ----------------- |
| Splits bundle  | Loads chunk later |
| Build-time     | Runtime behavior  |

---

## 5Ô∏è‚É£ When should you use Lazy Loading?

* Large components
* Route-based pages
* Heavy libraries (charts, editors)
* Modals & dashboards

---

## 6Ô∏è‚É£ How does React support Lazy Loading?

Using:

* `React.lazy()`
* `Suspense`

---

## 7Ô∏è‚É£ Basic Lazy Loading Example

```jsx
import React, { Suspense } from "react";

const Dashboard = React.lazy(() => import("./Dashboard"));

function App() {
  return (
    <Suspense fallback={<h2>Loading...</h2>}>
      <Dashboard />
    </Suspense>
  );
}
```

---

## 8Ô∏è‚É£ What is Suspense?

Suspense shows a **fallback UI** while a lazy component is loading.

```jsx
<Suspense fallback={<Loader />}>
  <Component />
</Suspense>
```

---

## 9Ô∏è‚É£ Can Suspense work without React.lazy?

‚ùå No (for component code splitting)

---

## üîü Route-based Code Splitting (MOST COMMON)

```jsx
const Home = React.lazy(() => import("./pages/Home"));
const Profile = React.lazy(() => import("./pages/Profile"));

<Routes>
  <Route
    path="/"
    element={
      <Suspense fallback={<Loader />}>
        <Home />
      </Suspense>
    }
  />
</Routes>
```

---

## 1Ô∏è‚É£1Ô∏è‚É£ Better Pattern (Recommended)

```jsx
<Suspense fallback={<Loader />}>
  <Routes>
    <Route path="/" element={<Home />} />
    <Route path="/profile" element={<Profile />} />
  </Routes>
</Suspense>
```

---

## 1Ô∏è‚É£2Ô∏è‚É£ Lazy Loading with Named Exports

‚ùå Not supported directly

‚úÖ Solution:

```jsx
const MyComp = React.lazy(() =>
  import("./MyComp").then(module => ({
    default: module.MyComp
  }))
);
```

---

## 1Ô∏è‚É£3Ô∏è‚É£ Lazy Loading Components vs Libraries

Components ‚Üí React.lazy
Libraries ‚Üí Dynamic import

```jsx
const loadChart = async () => {
  const chart = await import("chart.js");
};
```

---

## 1Ô∏è‚É£4Ô∏è‚É£ What is Dynamic Import?

JavaScript feature to load modules asynchronously.

```js
import("./utils").then(module => module.func());
```

---

## 1Ô∏è‚É£5Ô∏è‚É£ Lazy Loading Modal Example

```jsx
const Modal = React.lazy(() => import("./Modal"));

{show && (
  <Suspense fallback={null}>
    <Modal />
  </Suspense>
)}
```

---

## 1Ô∏è‚É£6Ô∏è‚É£ What happens behind the scenes?

* Webpack/Vite creates chunks
* Browser downloads chunk when needed
* React renders after load

---

## 1Ô∏è‚É£7Ô∏è‚É£ Code Splitting without React.lazy?

Yes, using dynamic imports.

```js
if (condition) {
  import("./feature").then(f => f.init());
}
```

---

## 1Ô∏è‚É£8Ô∏è‚É£ Difference between Eager & Lazy loading?

| Eager             | Lazy            |
| ----------------- | --------------- |
| Loads immediately | Loads on demand |
| Slower startup    | Faster startup  |

---

## 1Ô∏è‚É£9Ô∏è‚É£ Error Handling in Lazy Loading

Use **Error Boundary**.

```jsx
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  render() {
    return this.state.hasError
      ? <h3>Error loading</h3>
      : this.props.children;
  }
}
```

---

## 2Ô∏è‚É£0Ô∏è‚É£ Lazy Loading with Error Boundary

```jsx
<ErrorBoundary>
  <Suspense fallback={<Loader />}>
    <HeavyComponent />
  </Suspense>
</ErrorBoundary>
```

---

## 2Ô∏è‚É£1Ô∏è‚É£ Does Lazy Loading improve SEO?

‚ùå Not directly
‚úÖ Works with SSR (Next.js)

---

## 2Ô∏è‚É£2Ô∏è‚É£ Code Splitting in Next.js

Automatic per-page splitting.

```js
import dynamic from "next/dynamic";

const Chart = dynamic(() => import("../Chart"), {
  ssr: false,
  loading: () => <Loader />
});
```

---

## 2Ô∏è‚É£3Ô∏è‚É£ Vite vs Webpack (Code Splitting)

| Vite              | Webpack      |
| ----------------- | ------------ |
| Native ES modules | Bundle-based |
| Faster dev        | Slower dev   |

---

## 2Ô∏è‚É£4Ô∏è‚É£ Preloading Lazy Components

```js
const Page = React.lazy(() => import("./Page"));

Page.preload = () => import("./Page");
```

---

## 2Ô∏è‚É£5Ô∏è‚É£ What is Chunk?

A split JavaScript file created during build.

---

## 2Ô∏è‚É£6Ô∏è‚É£ Common Mistakes

‚ùå Lazy loading small components
‚ùå Missing Suspense
‚ùå No fallback UI
‚ùå Over-splitting

---

## 2Ô∏è‚É£7Ô∏è‚É£ Performance Best Practices

* Lazy load routes
* Lazy load heavy libs
* Use skeleton loaders
* Avoid nested Suspense abuse

---

## 2Ô∏è‚É£8Ô∏è‚É£ Interview One-Liner

"Code splitting breaks the bundle into smaller chunks, while lazy loading loads those chunks only when required."

---

## 2Ô∏è‚É£9Ô∏è‚É£ When NOT to use Lazy Loading?

* Small apps
* Critical UI
* Above-the-fold content

---

## 3Ô∏è‚É£0Ô∏è‚É£ MUST PRACTICE BEFORE INTERVIEW

‚úÖ React.lazy
‚úÖ Suspense
‚úÖ Route-based splitting
‚úÖ Error boundaries
‚úÖ Dynamic import

---

üéØ YOU ARE NOW INTERVIEW-READY FOR
üî• **CODE SPLITTING & LAZY LOADING**
