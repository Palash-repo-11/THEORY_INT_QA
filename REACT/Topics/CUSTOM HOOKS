# ğŸ”µ CUSTOM HOOKS â€“ REACT INTERVIEW QUESTIONS WITH ANSWERS & CODE

---

## 1ï¸âƒ£ What is a Custom Hook?

A **custom hook** is a **JavaScript function** that:

* Starts with `use`
* Reuses **stateful logic**
* Uses React hooks internally

```js
function useCounter() {
  const [count, setCount] = useState(0);
  return { count, setCount };
}
```

---

## 2ï¸âƒ£ Why do we need Custom Hooks?

* Reuse logic across components
* Cleaner components
* Better separation of concerns
* Avoid code duplication

---

## 3ï¸âƒ£ When should you create a Custom Hook?

* Same logic used in **multiple components**
* Logic unrelated to UI
* Complex side-effect handling

---

## 4ï¸âƒ£ Rules of Custom Hooks

* Must start with `use`
* Can use other hooks
* Cannot be called conditionally
* Must be called at top level

---

## 5ï¸âƒ£ Custom Hook vs Component

| Custom Hook            | Component    |
| ---------------------- | ------------ |
| Logic reuse            | UI rendering |
| Returns data/functions | Returns JSX  |

---

## 6ï¸âƒ£ Simple Custom Hook Example

### useToggle

```js
import { useState } from "react";

function useToggle(initial = false) {
  const [value, setValue] = useState(initial);

  const toggle = () => setValue(v => !v);

  return [value, toggle];
}
```

Usage:

```js
const [isOpen, toggle] = useToggle();
```

---

## 7ï¸âƒ£ Custom Hook with useEffect

### useOnlineStatus

```js
function useOnlineStatus() {
  const [online, setOnline] = useState(navigator.onLine);

  useEffect(() => {
    const goOnline = () => setOnline(true);
    const goOffline = () => setOnline(false);

    window.addEventListener("online", goOnline);
    window.addEventListener("offline", goOffline);

    return () => {
      window.removeEventListener("online", goOnline);
      window.removeEventListener("offline", goOffline);
    };
  }, []);

  return online;
}
```

---

## 8ï¸âƒ£ Why cleanup is important in Custom Hooks?

* Prevent memory leaks
* Shared logic must be safe
* Cleanup happens per component

---

## 9ï¸âƒ£ Custom Hook for API Calls

### useFetch

```js
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const controller = new AbortController();

    async function fetchData() {
      try {
        const res = await fetch(url, { signal: controller.signal });
        const json = await res.json();
        setData(json);
      } catch (err) {
        if (err.name !== "AbortError") setError(err);
      } finally {
        setLoading(false);
      }
    }

    fetchData();

    return () => controller.abort();
  }, [url]);

  return { data, loading, error };
}
```

---

## ğŸ”Ÿ How to pass parameters to Custom Hooks?

```js
const { data } = useFetch("/users");
```

---

## 1ï¸âƒ£1ï¸âƒ£ Custom Hook returning functions

```js
function useCounter() {
  const [count, setCount] = useState(0);

  const inc = () => setCount(c => c + 1);
  const dec = () => setCount(c => c - 1);

  return { count, inc, dec };
}
```

---

## 1ï¸âƒ£2ï¸âƒ£ Custom Hook with useCallback

```js
function useSearch() {
  const search = useCallback((term) => {
    console.log(term);
  }, []);

  return search;
}
```

---

## 1ï¸âƒ£3ï¸âƒ£ Custom Hook vs HOC

| Custom Hook | HOC             |
| ----------- | --------------- |
| Cleaner     | Wrapper hell    |
| Composable  | Harder to debug |
| Modern      | Legacy pattern  |

---

## 1ï¸âƒ£4ï¸âƒ£ Custom Hook vs Render Props

Custom Hooks are:

* Easier
* Less boilerplate
* More readable

---

## 1ï¸âƒ£5ï¸âƒ£ Can Custom Hooks share state?

âŒ NO
Each call gets **independent state**

---

## 1ï¸âƒ£6ï¸âƒ£ How to share state using Custom Hooks?

Use:

* Context
* Redux

---

## 1ï¸âƒ£7ï¸âƒ£ Custom Hook with Context

```js
function useAuth() {
  return useContext(AuthContext);
}
```

---

## 1ï¸âƒ£8ï¸âƒ£ Naming Convention

âœ… useSomething
âŒ getDataHook

---

## 1ï¸âƒ£9ï¸âƒ£ Testing Custom Hooks

Using React Testing Library:

```js
renderHook(() => useCounter());
```

---

## 2ï¸âƒ£0ï¸âƒ£ Common Mistakes

âŒ Calling hook inside condition
âŒ Returning JSX
âŒ Missing dependencies
âŒ Over-abstracting logic

---

## 2ï¸âƒ£1ï¸âƒ£ Performance Considerations

* Memoize returned functions
* Avoid unnecessary effects
* Avoid over-customization

---

## 2ï¸âƒ£2ï¸âƒ£ Custom Hook Folder Structure

```
src/
 â”œâ”€â”€ hooks/
 â”‚    â”œâ”€â”€ useFetch.js
 â”‚    â”œâ”€â”€ useToggle.js
```

---

## 2ï¸âƒ£3ï¸âƒ£ Real-World Custom Hooks Examples

* useDebounce
* useThrottle
* useAuth
* useForm
* useTheme

---

## 2ï¸âƒ£4ï¸âƒ£ useDebounce Example

```js
function useDebounce(value, delay) {
  const [debounced, setDebounced] = useState(value);

  useEffect(() => {
    const id = setTimeout(() => setDebounced(value), delay);
    return () => clearTimeout(id);
  }, [value, delay]);

  return debounced;
}
```

---

## 2ï¸âƒ£5ï¸âƒ£ Interview One-Liner

"Custom hooks allow reusable, clean, and composable stateful logic across React components."

---

## 2ï¸âƒ£6ï¸âƒ£ When NOT to use Custom Hooks?

* UI logic
* One-time logic
* Simple state

---

## 2ï¸âƒ£7ï¸âƒ£ MUST PRACTICE BEFORE INTERVIEW

âœ… useFetch
âœ… useDebounce
âœ… Cleanup handling
âœ… Context + hook
âœ… Dependency management

---

ğŸ¯ YOU ARE NOW INTERVIEW-READY FOR
ğŸ”¥ **CUSTOM HOOKS IN REACT**





# ğŸ”µ ADVANCED CUSTOM HOOKS â€“ INTERVIEW Q&A WITH CODE

---

## âœ… 1ï¸âƒ£ useFetch â€“ Questions & Code

### Q1. What is useFetch?

A custom hook that **encapsulates API logic** (loading, data, error) for reuse.

---

### Q2. Why not fetch directly inside components?

* Code duplication
* Hard to test
* Poor separation of concerns

---

### Q3. Basic useFetch Implementation

```js
import { useEffect, useState } from "react";

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let isMounted = true;

    async function fetchData() {
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error("Failed");
        const json = await res.json();
        if (isMounted) setData(json);
      } catch (err) {
        if (isMounted) setError(err.message);
      } finally {
        if (isMounted) setLoading(false);
      }
    }

    fetchData();

    return () => {
      isMounted = false;
    };
  }, [url]);

  return { data, loading, error };
}
```

---

### Q4. useFetch with AbortController (BEST PRACTICE)

```js
useEffect(() => {
  const controller = new AbortController();

  fetch(url, { signal: controller.signal });

  return () => controller.abort();
}, [url]);
```

---

### Q5. Interview One-liner

"`useFetch` abstracts API logic into a reusable hook with proper loading, error, and cleanup handling."

---

## âœ… 2ï¸âƒ£ useDebounce â€“ Questions & Code

---

### Q6. What is Debouncing?

Delays execution until user **stops triggering an event**.

ğŸ“Œ Used in search, filters, input validation.

---

### Q7. useDebounce Custom Hook

```js
import { useEffect, useState } from "react";

function useDebounce(value, delay = 500) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
}
```

---

### Q8. How to use useDebounce?

```js
const debouncedSearch = useDebounce(searchText, 400);

useEffect(() => {
  fetch(`/api?q=${debouncedSearch}`);
}, [debouncedSearch]);
```

---

### Q9. Debounce vs Throttle?

| Debounce | Throttle         |
| -------- | ---------------- |
| Waits    | Limits frequency |
| Search   | Scroll events    |

---

## âœ… 3ï¸âƒ£ Cleanup Handling â€“ Questions & Code

---

### Q10. What is Cleanup in Hooks?

Cleanup removes **side effects** before re-run or unmount.

---

### Q11. Why Cleanup is Mandatory?

* Prevent memory leaks
* Avoid duplicated listeners
* Cancel async tasks

---

### Q12. Cleanup Example â€“ Event Listener

```js
useEffect(() => {
  const onScroll = () => console.log("scrolling");

  window.addEventListener("scroll", onScroll);

  return () => {
    window.removeEventListener("scroll", onScroll);
  };
}, []);
```

---

### Q13. Cleanup Example â€“ setTimeout

```js
useEffect(() => {
  const id = setTimeout(() => {}, 1000);
  return () => clearTimeout(id);
}, []);
```

---

### Q14. Interview Trap

âŒ Forgetting cleanup in custom hooks is a **production bug**

---

## âœ… 4ï¸âƒ£ Context + Custom Hook â€“ Questions & Code

---

### Q15. Why combine Context with Custom Hooks?

* Clean API
* No repeated `useContext`
* Better abstraction

---

### Q16. Auth Context Setup

```js
import { createContext, useContext, useState } from "react";

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);

  const login = (userData) => setUser(userData);
  const logout = () => setUser(null);

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}
```

---

### Q17. Custom Hook for Context

```js
export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used inside AuthProvider");
  }
  return context;
}
```

---

### Q18. Usage

```js
const { user, login, logout } = useAuth();
```

---

### Q19. Interview One-liner

"Context + custom hooks provide a clean and scalable way to share global state."

---

## âœ… 5ï¸âƒ£ Dependency Management â€“ Questions & Code

---

### Q20. What is Dependency Array?

Controls **when effects re-run**.

---

### Q21. Why Dependency Management is critical?

* Prevent stale data
* Avoid infinite loops
* Ensure correctness

---

### Q22. Missing Dependency Bug

```js
useEffect(() => {
  console.log(count);
}, []); // âŒ count missing
```

---

### Q23. Correct Dependency Usage

```js
useEffect(() => {
  console.log(count);
}, [count]);
```

---

### Q24. Functions in Dependency Array?

Yes â€” unless memoized.

```js
const fetchData = useCallback(() => {}, []);

useEffect(() => {
  fetchData();
}, [fetchData]);
```

---

### Q25. ESLint Warning â€“ Should you ignore?

âŒ NO
Fix root cause or memoize dependencies.

---

### Q26. Infinite Loop Example

```js
useEffect(() => {
  setValue(value + 1);
}, [value]); // âŒ
```

---

### Q27. Fix with Functional Update

```js
useEffect(() => {
  setValue(v => v + 1);
}, []);
```

---

## âœ… MOST ASKED INTERVIEW QUESTIONS (RAPID FIRE)

* Can custom hooks share state? âŒ
* Is cleanup required in custom hooks? âœ…
* Does useDebounce need cleanup? âœ…
* Should functions be dependencies? âœ…
* Can hooks return JSX? âŒ

---

## ğŸ¯ FINAL INTERVIEW ONE-LINER

"Advanced custom hooks like useFetch and useDebounce encapsulate reusable logic, manage dependencies correctly, and prevent memory leaks through proper cleanup."

---

## ğŸš€ YOU ARE NOW STRONG IN:

âœ… Real-world hooks
âœ… Cleanup & performance
âœ… Dependency correctness
âœ… Context architecture

---

If you want next (very high value):

* ğŸ”¥ **useMemo & useCallback (with traps)**
* ğŸ”¥ **useRef (DOM + state escape hatch)**
* ğŸ”¥ **React performance interview questions**
* ğŸ”¥ **Senior-level React scenarios**

Just tell me ğŸ‘
