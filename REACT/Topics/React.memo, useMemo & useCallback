# ğŸ”µ React.memo, useMemo & useCallback â€“ INTERVIEW QUESTIONS WITH ANSWERS & CODE

---

## 1ï¸âƒ£ What is React.memo?

`React.memo` is a **Higher Order Component** used to **prevent unnecessary re-renders** of a component when props donâ€™t change.

```js
export default React.memo(MyComponent);
```

---

## 2ï¸âƒ£ When does React.memo re-render?

* Re-renders only if **props change (shallow comparison)**

---

## 3ï¸âƒ£ Why do we need React.memo?

* Improve performance
* Avoid wasted re-renders
* Optimize child components

---

## 4ï¸âƒ£ Basic React.memo Example

```jsx
const Child = React.memo(({ name }) => {
  console.log("Child rendered");
  return <h3>{name}</h3>;
});

export default Child;
```

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(c => c + 1)}>+</button>
      <Child name="Palash" />
    </>
  );
}
```

âœ… Child will NOT re-render when count changes.

---

## 5ï¸âƒ£ Why React.memo sometimes fails?

Because of **reference types** (objects/functions).

```js
<Child user={{ name: "Palash" }} /> // âŒ new object every render
```

---

## 6ï¸âƒ£ Fix React.memo using useMemo

```js
const user = useMemo(() => ({ name: "Palash" }), []);
<Child user={user} />
```

---

## 7ï¸âƒ£ What is useMemo?

`useMemo` **memoizes a computed value** to avoid expensive recalculation.

```js
const memoValue = useMemo(() => compute(), [deps]);
```

---

## 8ï¸âƒ£ When should you use useMemo?

* Heavy calculations
* Stable object/array references
* Prevent child re-renders

---

## 9ï¸âƒ£ useMemo Example â€“ Expensive Calculation

```js
const result = useMemo(() => {
  return heavyCalculation(count);
}, [count]);
```

---

## ğŸ”Ÿ useMemo Example â€“ Fix Reference Issue

```js
const data = useMemo(() => ({ id: 1 }), []);
<Child data={data} />
```

---

## 1ï¸âƒ£1ï¸âƒ£ What is useCallback?

`useCallback` memoizes **function references**.

```js
const handleClick = useCallback(() => {
  console.log("clicked");
}, []);
```

---

## 1ï¸âƒ£2ï¸âƒ£ When should you use useCallback?

* Passing functions to memoized components
* Event handlers
* Dependency arrays

---

## 1ï¸âƒ£3ï¸âƒ£ useCallback Example with React.memo

```jsx
const Button = React.memo(({ onClick }) => {
  console.log("Button rendered");
  return <button onClick={onClick}>Click</button>;
});

function Parent() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    console.log("clicked");
  }, []);

  return (
    <>
      <button onClick={() => setCount(c => c + 1)}>+</button>
      <Button onClick={handleClick} />
    </>
  );
}
```

---

## 1ï¸âƒ£4ï¸âƒ£ useCallback vs useMemo

| useCallback       | useMemo         |
| ----------------- | --------------- |
| Memoizes function | Memoizes value  |
| Returns function  | Returns value   |
| useMemo(() => fn) | useCallback(fn) |

---

## 1ï¸âƒ£5ï¸âƒ£ React.memo vs useMemo vs useCallback

| Tool        | Purpose           |
| ----------- | ----------------- |
| React.memo  | Memoize component |
| useMemo     | Memoize value     |
| useCallback | Memoize function  |

---

## 1ï¸âƒ£6ï¸âƒ£ Custom Comparison in React.memo

```js
export default React.memo(Component, (prev, next) => {
  return prev.id === next.id;
});
```

---

## 1ï¸âƒ£7ï¸âƒ£ When NOT to use memoization?

âŒ Small components
âŒ Cheap calculations
âŒ Premature optimization

---

## 1ï¸âƒ£8ï¸âƒ£ Common Mistakes

âŒ Overusing useMemo
âŒ Empty dependency arrays blindly
âŒ Memoizing everything
âŒ Forgetting dependencies

---

## 1ï¸âƒ£9ï¸âƒ£ Performance Cost of Memoization

* Extra memory
* Comparison overhead

â¡ï¸ Use only when needed.

---

## 2ï¸âƒ£0ï¸âƒ£ Real-World Optimization Pattern

```jsx
const items = useMemo(() => list.map(x => x.id), [list]);
const onSelect = useCallback(id => setId(id), []);
```

---

## 2ï¸âƒ£1ï¸âƒ£ Infinite Loop Trap

```js
useEffect(() => {
  fetchData();
}, [fetchData]); // fetchData recreated
```

âœ… Fix:

```js
const fetchData = useCallback(() => {}, []);
```

---

## 2ï¸âƒ£2ï¸âƒ£ Interview One-Liners

* **React.memo**: Prevents re-render if props unchanged
* **useMemo**: Caches expensive values
* **useCallback**: Caches function references

---

## 2ï¸âƒ£3ï¸âƒ£ Senior-Level Interview Question

â“ Should we use useMemo everywhere?

âœ… **No** â€” measure first, optimize later.

---

## 2ï¸âƒ£4ï¸âƒ£ MUST PRACTICE BEFORE INTERVIEW

âœ… React.memo + props
âœ… useMemo for objects/arrays
âœ… useCallback for functions
âœ… Dependency correctness
âœ… Reference equality

---

## ğŸ¯ FINAL INTERVIEW STATEMENT

"React.memo, useMemo, and useCallback are performance tools that prevent unnecessary re-renders by stabilizing references, but they should be used selectively."

---

## ğŸš€ YOU ARE NOW STRONG IN:

ğŸ”¥ React performance
ğŸ”¥ Memoization
ğŸ”¥ Senior-level optimization

---

If you want next (recommended for your profile):

* âš¡ **useRef deep dive**
* âš¡ **Virtual DOM & reconciliation**
* âš¡ **React rendering lifecycle**
* âš¡ **Senior React interview scenarios**

Just tell me ğŸ‘
