# üîµ useEffect, Dependency Array & Cleanup ‚Äì INTERVIEW QUESTIONS WITH ANSWERS & CODE

---

## 1Ô∏è‚É£ What is useEffect?

`useEffect` is a React Hook used to perform **side effects** in functional components.

‚û°Ô∏è Side effects = API calls, subscriptions, timers, DOM updates

```jsx
useEffect(() => {
  console.log("Component mounted");
});
```

---

## 2Ô∏è‚É£ Why do we need useEffect?

* Replace lifecycle methods (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`)
* Handle async logic
* Sync React with external systems

---

## 3Ô∏è‚É£ When does useEffect run?

By default:

* Runs **after every render**

---

## 4Ô∏è‚É£ Syntax of useEffect

```jsx
useEffect(() => {
  // side effect
  return () => {
    // cleanup
  };
}, [dependencies]);
```

---

## 5Ô∏è‚É£ What is Dependency Array?

Dependency array controls **when useEffect runs**.

```jsx
useEffect(() => {
  console.log("Runs when count changes");
}, [count]);
```

---

## 6Ô∏è‚É£ Types of Dependency Array

### üîπ No dependency array

Runs on **every render**

```jsx
useEffect(() => {
  console.log("Every render");
});
```

---

### üîπ Empty dependency array `[]`

Runs **only once (on mount)**

```jsx
useEffect(() => {
  console.log("Component mounted");
}, []);
```

---

### üîπ With dependencies

Runs when dependency changes

```jsx
useEffect(() => {
  console.log("Count changed");
}, [count]);
```

---

## 7Ô∏è‚É£ What happens if dependency is missing?

‚ùå Stale data
‚ùå Infinite loops
‚ùå Bugs

---

## 8Ô∏è‚É£ Why ESLint warns about dependencies?

To prevent:

* Stale closures
* Missed updates
* Unexpected behavior

---

## 9Ô∏è‚É£ What is Cleanup Function?

Cleanup runs:

* Before component unmounts
* Before effect re-runs

```jsx
useEffect(() => {
  return () => {
    console.log("Cleanup");
  };
}, []);
```

---

## üîü Why Cleanup is important?

* Prevent memory leaks
* Remove event listeners
* Clear timers
* Cancel subscriptions

---

## 1Ô∏è‚É£1Ô∏è‚É£ Cleanup Example ‚Äì Event Listener

```jsx
useEffect(() => {
  const handleResize = () => console.log("Resized");

  window.addEventListener("resize", handleResize);

  return () => {
    window.removeEventListener("resize", handleResize);
  };
}, []);
```

---

## 1Ô∏è‚É£2Ô∏è‚É£ Cleanup Example ‚Äì setInterval

```jsx
useEffect(() => {
  const id = setInterval(() => {
    console.log("Running...");
  }, 1000);

  return () => clearInterval(id);
}, []);
```

---

## 1Ô∏è‚É£3Ô∏è‚É£ Cleanup Example ‚Äì API call (AbortController)

```jsx
useEffect(() => {
  const controller = new AbortController();

  fetch("/api/data", { signal: controller.signal });

  return () => controller.abort();
}, []);
```

---

## 1Ô∏è‚É£4Ô∏è‚É£ useEffect vs Lifecycle Methods

| Class                | Hook             |
| -------------------- | ---------------- |
| componentDidMount    | useEffect([],)   |
| componentDidUpdate   | useEffect([dep]) |
| componentWillUnmount | cleanup function |

---

## 1Ô∏è‚É£5Ô∏è‚É£ What is Infinite Loop in useEffect?

Updating a dependency inside effect.

‚ùå Wrong

```jsx
useEffect(() => {
  setCount(count + 1);
}, [count]);
```

---

## 1Ô∏è‚É£6Ô∏è‚É£ Fix Infinite Loop

```jsx
useEffect(() => {
  setCount(c => c + 1);
}, []);
```

---

## 1Ô∏è‚É£7Ô∏è‚É£ Can we use async directly in useEffect?

‚ùå No

‚úÖ Correct way:

```jsx
useEffect(() => {
  async function fetchData() {
    const res = await fetch("/api");
  }
  fetchData();
}, []);
```

---

## 1Ô∏è‚É£8Ô∏è‚É£ Multiple useEffect?

‚úÖ Yes
Best practice: **separate concerns**

```jsx
useEffect(() => {}, [user]);
useEffect(() => {}, [theme]);
```

---

## 1Ô∏è‚É£9Ô∏è‚É£ What is Stale Closure?

Effect using **old state value**.

```jsx
useEffect(() => {
  setTimeout(() => {
    console.log(count); // old value
  }, 1000);
}, []);
```

---

## 2Ô∏è‚É£0Ô∏è‚É£ Fix Stale Closure

```jsx
useEffect(() => {
  setTimeout(() => {
    setCount(c => c + 1);
  }, 1000);
}, []);
```

---

## 2Ô∏è‚É£1Ô∏è‚É£ Should functions be in dependency array?

‚úÖ Yes (unless memoized)

```jsx
useEffect(() => {
  fetchData();
}, [fetchData]);
```

---

## 2Ô∏è‚É£2Ô∏è‚É£ How to avoid function dependency?

Use `useCallback`.

```jsx
const fetchData = useCallback(() => {
  // logic
}, []);
```

---

## 2Ô∏è‚É£3Ô∏è‚É£ useEffect vs useLayoutEffect

| useEffect   | useLayoutEffect |
| ----------- | --------------- |
| Async       | Sync            |
| After paint | Before paint    |

---

## 2Ô∏è‚É£4Ô∏è‚É£ When to use useLayoutEffect?

* DOM measurements
* Prevent flickering

---

## 2Ô∏è‚É£5Ô∏è‚É£ useEffect Cleanup Order

1. Cleanup old effect
2. Run new effect
3. Cleanup on unmount

---

## 2Ô∏è‚É£6Ô∏è‚É£ Common Mistakes

‚ùå Missing dependency
‚ùå Overusing empty array
‚ùå No cleanup
‚ùå Business logic inside effect

---

## 2Ô∏è‚É£7Ô∏è‚É£ Performance Tips

* Split effects
* Memoize functions
* Avoid unnecessary dependencies

---

## 2Ô∏è‚É£8Ô∏è‚É£ Interview One-Liner

"`useEffect` handles side effects and dependency array controls when it runs, while cleanup prevents memory leaks."

---

## 2Ô∏è‚É£9Ô∏è‚É£ When NOT to use useEffect?

* Pure calculations
* Rendering logic
* Derived state

---

## 3Ô∏è‚É£0Ô∏è‚É£ MUST PRACTICE BEFORE INTERVIEW

‚úÖ Dependency behavior
‚úÖ Cleanup logic
‚úÖ Infinite loop fixes
‚úÖ Stale closure
‚úÖ Async handling

---

üéØ YOU ARE NOW INTERVIEW-READY FOR
üî• **useEffect, Dependency Array & Cleanup**
